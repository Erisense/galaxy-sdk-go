// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package table

import (
	"bytes"
	"fmt"
	"github.com/XiaoMi/galaxy-sdk-go/sds/auth"
	"github.com/XiaoMi/galaxy-sdk-go/sds/common"
	"github.com/XiaoMi/galaxy-sdk-go/sds/errors"
	"github.com/XiaoMi/galaxy-sdk-go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var _ = errors.GoUnusedProtection__
var _ = common.GoUnusedProtection__
var _ = auth.GoUnusedProtection__

type TableService interface {
	common.BaseService
	//结构化存储表数据访问接口

	// 读操作，需要1个读配额
	//
	// Parameters:
	//  - Request
	Get(request *GetRequest) (r *GetResult_, err error)
	// 写操作，需要1个写配额，另外每个Eager二级索引需要1个额外读配额
	//
	// Parameters:
	//  - Request
	Put(request *PutRequest) (r *PutResult_, err error)
	// 自增操作，需要读写配额各1
	//
	// Parameters:
	//  - Request
	Increment(request *IncrementRequest) (r *IncrementResult_, err error)
	// 删除操作，需要1个写配额，另外每个Eager二级索引需要1个额外读配额
	//
	// Parameters:
	//  - Request
	Remove(request *RemoveRequest) (r *RemoveResult_, err error)
	// 扫描操作，每个扫描过的记录消耗1个读配额(即使不满足过滤条件)，每个Lazy二级索引需要1个额外读配额
	//
	// Parameters:
	//  - Request
	Scan(request *ScanRequest) (r *ScanResult_, err error)
	// 批量读写操作，消耗各自对应的读写配额。同一个batch中多个操作修改同一行数据可能导致未定义行为（数据不一致），
	// 应当避免，另外如果一个batch包含同一行的读和写操作，其执行顺序是不确定的，不推荐使用
	//
	// Parameters:
	//  - Request
	Batch(request *BatchRequest) (r *BatchResult_, err error)
}

//结构化存储表数据访问接口
type TableServiceClient struct {
	*common.BaseServiceClient
}

func NewTableServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *TableServiceClient {
	return &TableServiceClient{BaseServiceClient: common.NewBaseServiceClientFactory(t, f)}
}

func NewTableServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *TableServiceClient {
	return &TableServiceClient{BaseServiceClient: common.NewBaseServiceClientProtocol(t, iprot, oprot)}
}

// 读操作，需要1个读配额
//
// Parameters:
//  - Request
func (p *TableServiceClient) Get(request *GetRequest) (r *GetResult_, err error) {
	if err = p.sendGet(request); err != nil {
		return
	}
	return p.recvGet()
}

func (p *TableServiceClient) sendGet(request *GetRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TableServiceClient) recvGet() (value *GetResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error53 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error54 error
		error54, err = error53.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error54
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	result := GetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Se != nil {
		err = result.Se
		return
	}
	value = result.GetSuccess()
	return
}

// 写操作，需要1个写配额，另外每个Eager二级索引需要1个额外读配额
//
// Parameters:
//  - Request
func (p *TableServiceClient) Put(request *PutRequest) (r *PutResult_, err error) {
	if err = p.sendPut(request); err != nil {
		return
	}
	return p.recvPut()
}

func (p *TableServiceClient) sendPut(request *PutRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("put", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := PutArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TableServiceClient) recvPut() (value *PutResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "put failed: out of sequence response")
		return
	}
	result := PutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Se != nil {
		err = result.Se
		return
	}
	value = result.GetSuccess()
	return
}

// 自增操作，需要读写配额各1
//
// Parameters:
//  - Request
func (p *TableServiceClient) Increment(request *IncrementRequest) (r *IncrementResult_, err error) {
	if err = p.sendIncrement(request); err != nil {
		return
	}
	return p.recvIncrement()
}

func (p *TableServiceClient) sendIncrement(request *IncrementRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("increment", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := IncrementArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TableServiceClient) recvIncrement() (value *IncrementResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error57 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error58 error
		error58, err = error57.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error58
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "increment failed: out of sequence response")
		return
	}
	result := IncrementResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Se != nil {
		err = result.Se
		return
	}
	value = result.GetSuccess()
	return
}

// 删除操作，需要1个写配额，另外每个Eager二级索引需要1个额外读配额
//
// Parameters:
//  - Request
func (p *TableServiceClient) Remove(request *RemoveRequest) (r *RemoveResult_, err error) {
	if err = p.sendRemove(request); err != nil {
		return
	}
	return p.recvRemove()
}

func (p *TableServiceClient) sendRemove(request *RemoveRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("remove", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := RemoveArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TableServiceClient) recvRemove() (value *RemoveResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "remove failed: out of sequence response")
		return
	}
	result := RemoveResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Se != nil {
		err = result.Se
		return
	}
	value = result.GetSuccess()
	return
}

// 扫描操作，每个扫描过的记录消耗1个读配额(即使不满足过滤条件)，每个Lazy二级索引需要1个额外读配额
//
// Parameters:
//  - Request
func (p *TableServiceClient) Scan(request *ScanRequest) (r *ScanResult_, err error) {
	if err = p.sendScan(request); err != nil {
		return
	}
	return p.recvScan()
}

func (p *TableServiceClient) sendScan(request *ScanRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scan", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScanArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TableServiceClient) recvScan() (value *ScanResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error61 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error62 error
		error62, err = error61.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error62
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scan failed: out of sequence response")
		return
	}
	result := ScanResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Se != nil {
		err = result.Se
		return
	}
	value = result.GetSuccess()
	return
}

// 批量读写操作，消耗各自对应的读写配额。同一个batch中多个操作修改同一行数据可能导致未定义行为（数据不一致），
// 应当避免，另外如果一个batch包含同一行的读和写操作，其执行顺序是不确定的，不推荐使用
//
// Parameters:
//  - Request
func (p *TableServiceClient) Batch(request *BatchRequest) (r *BatchResult_, err error) {
	if err = p.sendBatch(request); err != nil {
		return
	}
	return p.recvBatch()
}

func (p *TableServiceClient) sendBatch(request *BatchRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("batch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := BatchArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TableServiceClient) recvBatch() (value *BatchResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "batch failed: out of sequence response")
		return
	}
	result := BatchResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Se != nil {
		err = result.Se
		return
	}
	value = result.GetSuccess()
	return
}

type TableServiceProcessor struct {
	*common.BaseServiceProcessor
}

func NewTableServiceProcessor(handler TableService) *TableServiceProcessor {
	self65 := &TableServiceProcessor{common.NewBaseServiceProcessor(handler)}
	self65.AddToProcessorMap("get", &tableServiceProcessorGet{handler: handler})
	self65.AddToProcessorMap("put", &tableServiceProcessorPut{handler: handler})
	self65.AddToProcessorMap("increment", &tableServiceProcessorIncrement{handler: handler})
	self65.AddToProcessorMap("remove", &tableServiceProcessorRemove{handler: handler})
	self65.AddToProcessorMap("scan", &tableServiceProcessorScan{handler: handler})
	self65.AddToProcessorMap("batch", &tableServiceProcessorBatch{handler: handler})
	return self65
}

type tableServiceProcessorGet struct {
	handler TableService
}

func (p *tableServiceProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetResult{}
	var retval *GetResult_
	var err2 error
	if retval, err2 = p.handler.Get(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *errors.ServiceException:
			result.Se = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tableServiceProcessorPut struct {
	handler TableService
}

func (p *tableServiceProcessorPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := PutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := PutResult{}
	var retval *PutResult_
	var err2 error
	if retval, err2 = p.handler.Put(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *errors.ServiceException:
			result.Se = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing put: "+err2.Error())
			oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("put", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tableServiceProcessorIncrement struct {
	handler TableService
}

func (p *tableServiceProcessorIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IncrementArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IncrementResult{}
	var retval *IncrementResult_
	var err2 error
	if retval, err2 = p.handler.Increment(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *errors.ServiceException:
			result.Se = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err2.Error())
			oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("increment", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tableServiceProcessorRemove struct {
	handler TableService
}

func (p *tableServiceProcessorRemove) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoveArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := RemoveResult{}
	var retval *RemoveResult_
	var err2 error
	if retval, err2 = p.handler.Remove(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *errors.ServiceException:
			result.Se = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove: "+err2.Error())
			oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("remove", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tableServiceProcessorScan struct {
	handler TableService
}

func (p *tableServiceProcessorScan) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScanArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scan", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScanResult{}
	var retval *ScanResult_
	var err2 error
	if retval, err2 = p.handler.Scan(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *errors.ServiceException:
			result.Se = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan: "+err2.Error())
			oprot.WriteMessageBegin("scan", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("scan", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tableServiceProcessorBatch struct {
	handler TableService
}

func (p *tableServiceProcessorBatch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := BatchArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("batch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := BatchResult{}
	var retval *BatchResult_
	var err2 error
	if retval, err2 = p.handler.Batch(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *errors.ServiceException:
			result.Se = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing batch: "+err2.Error())
			oprot.WriteMessageBegin("batch", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("batch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type GetArgs struct {
	Request *GetRequest `thrift:"request,1" json:"request"`
}

func NewGetArgs() *GetArgs {
	return &GetArgs{}
}

var GetArgs_Request_DEFAULT *GetRequest

func (p *GetArgs) GetRequest() *GetRequest {
	if !p.IsSetRequest() {
		return GetArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *GetArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &GetRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success *GetResult_              `thrift:"success,0" json:"success"`
	Se      *errors.ServiceException `thrift:"se,1" json:"se"`
}

func NewGetResult() *GetResult {
	return &GetResult{}
}

var GetResult_Success_DEFAULT *GetResult_

func (p *GetResult) GetSuccess() *GetResult_ {
	if !p.IsSetSuccess() {
		return GetResult_Success_DEFAULT
	}
	return p.Success
}

var GetResult_Se_DEFAULT *errors.ServiceException

func (p *GetResult) GetSe() *errors.ServiceException {
	if !p.IsSetSe() {
		return GetResult_Se_DEFAULT
	}
	return p.Se
}
func (p *GetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetResult) IsSetSe() bool {
	return p.Se != nil
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &GetResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Se = &errors.ServiceException{}
	if err := p.Se.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Se, err)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetSe() {
		if err := oprot.WriteFieldBegin("se", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:se: %s", p, err)
		}
		if err := p.Se.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Se, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:se: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type PutArgs struct {
	Request *PutRequest `thrift:"request,1" json:"request"`
}

func NewPutArgs() *PutArgs {
	return &PutArgs{}
}

var PutArgs_Request_DEFAULT *PutRequest

func (p *PutArgs) GetRequest() *PutRequest {
	if !p.IsSetRequest() {
		return PutArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *PutArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *PutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &PutRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *PutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *PutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutArgs(%+v)", *p)
}

type PutResult struct {
	Success *PutResult_              `thrift:"success,0" json:"success"`
	Se      *errors.ServiceException `thrift:"se,1" json:"se"`
}

func NewPutResult() *PutResult {
	return &PutResult{}
}

var PutResult_Success_DEFAULT *PutResult_

func (p *PutResult) GetSuccess() *PutResult_ {
	if !p.IsSetSuccess() {
		return PutResult_Success_DEFAULT
	}
	return p.Success
}

var PutResult_Se_DEFAULT *errors.ServiceException

func (p *PutResult) GetSe() *errors.ServiceException {
	if !p.IsSetSe() {
		return PutResult_Se_DEFAULT
	}
	return p.Se
}
func (p *PutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PutResult) IsSetSe() bool {
	return p.Se != nil
}

func (p *PutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &PutResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *PutResult) ReadField1(iprot thrift.TProtocol) error {
	p.Se = &errors.ServiceException{}
	if err := p.Se.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Se, err)
	}
	return nil
}

func (p *PutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *PutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetSe() {
		if err := oprot.WriteFieldBegin("se", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:se: %s", p, err)
		}
		if err := p.Se.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Se, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:se: %s", p, err)
		}
	}
	return err
}

func (p *PutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutResult(%+v)", *p)
}

type IncrementArgs struct {
	Request *IncrementRequest `thrift:"request,1" json:"request"`
}

func NewIncrementArgs() *IncrementArgs {
	return &IncrementArgs{}
}

var IncrementArgs_Request_DEFAULT *IncrementRequest

func (p *IncrementArgs) GetRequest() *IncrementRequest {
	if !p.IsSetRequest() {
		return IncrementArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *IncrementArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *IncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &IncrementRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *IncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *IncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementArgs(%+v)", *p)
}

type IncrementResult struct {
	Success *IncrementResult_        `thrift:"success,0" json:"success"`
	Se      *errors.ServiceException `thrift:"se,1" json:"se"`
}

func NewIncrementResult() *IncrementResult {
	return &IncrementResult{}
}

var IncrementResult_Success_DEFAULT *IncrementResult_

func (p *IncrementResult) GetSuccess() *IncrementResult_ {
	if !p.IsSetSuccess() {
		return IncrementResult_Success_DEFAULT
	}
	return p.Success
}

var IncrementResult_Se_DEFAULT *errors.ServiceException

func (p *IncrementResult) GetSe() *errors.ServiceException {
	if !p.IsSetSe() {
		return IncrementResult_Se_DEFAULT
	}
	return p.Se
}
func (p *IncrementResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IncrementResult) IsSetSe() bool {
	return p.Se != nil
}

func (p *IncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &IncrementResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *IncrementResult) ReadField1(iprot thrift.TProtocol) error {
	p.Se = &errors.ServiceException{}
	if err := p.Se.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Se, err)
	}
	return nil
}

func (p *IncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetSe() {
		if err := oprot.WriteFieldBegin("se", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:se: %s", p, err)
		}
		if err := p.Se.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Se, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:se: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementResult(%+v)", *p)
}

type RemoveArgs struct {
	Request *RemoveRequest `thrift:"request,1" json:"request"`
}

func NewRemoveArgs() *RemoveArgs {
	return &RemoveArgs{}
}

var RemoveArgs_Request_DEFAULT *RemoveRequest

func (p *RemoveArgs) GetRequest() *RemoveRequest {
	if !p.IsSetRequest() {
		return RemoveArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *RemoveArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *RemoveArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &RemoveRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *RemoveArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *RemoveArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveArgs(%+v)", *p)
}

type RemoveResult struct {
	Success *RemoveResult_           `thrift:"success,0" json:"success"`
	Se      *errors.ServiceException `thrift:"se,1" json:"se"`
}

func NewRemoveResult() *RemoveResult {
	return &RemoveResult{}
}

var RemoveResult_Success_DEFAULT *RemoveResult_

func (p *RemoveResult) GetSuccess() *RemoveResult_ {
	if !p.IsSetSuccess() {
		return RemoveResult_Success_DEFAULT
	}
	return p.Success
}

var RemoveResult_Se_DEFAULT *errors.ServiceException

func (p *RemoveResult) GetSe() *errors.ServiceException {
	if !p.IsSetSe() {
		return RemoveResult_Se_DEFAULT
	}
	return p.Se
}
func (p *RemoveResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoveResult) IsSetSe() bool {
	return p.Se != nil
}

func (p *RemoveResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &RemoveResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *RemoveResult) ReadField1(iprot thrift.TProtocol) error {
	p.Se = &errors.ServiceException{}
	if err := p.Se.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Se, err)
	}
	return nil
}

func (p *RemoveResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetSe() {
		if err := oprot.WriteFieldBegin("se", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:se: %s", p, err)
		}
		if err := p.Se.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Se, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:se: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveResult(%+v)", *p)
}

type ScanArgs struct {
	Request *ScanRequest `thrift:"request,1" json:"request"`
}

func NewScanArgs() *ScanArgs {
	return &ScanArgs{}
}

var ScanArgs_Request_DEFAULT *ScanRequest

func (p *ScanArgs) GetRequest() *ScanRequest {
	if !p.IsSetRequest() {
		return ScanArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ScanArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ScanArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScanArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &ScanRequest{
		Limit: 10,

		CacheResult_: true,

		SplitIndex: -1,
	}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *ScanArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scan_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScanArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *ScanArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScanArgs(%+v)", *p)
}

type ScanResult struct {
	Success *ScanResult_             `thrift:"success,0" json:"success"`
	Se      *errors.ServiceException `thrift:"se,1" json:"se"`
}

func NewScanResult() *ScanResult {
	return &ScanResult{}
}

var ScanResult_Success_DEFAULT *ScanResult_

func (p *ScanResult) GetSuccess() *ScanResult_ {
	if !p.IsSetSuccess() {
		return ScanResult_Success_DEFAULT
	}
	return p.Success
}

var ScanResult_Se_DEFAULT *errors.ServiceException

func (p *ScanResult) GetSe() *errors.ServiceException {
	if !p.IsSetSe() {
		return ScanResult_Se_DEFAULT
	}
	return p.Se
}
func (p *ScanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScanResult) IsSetSe() bool {
	return p.Se != nil
}

func (p *ScanResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScanResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ScanResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ScanResult) ReadField1(iprot thrift.TProtocol) error {
	p.Se = &errors.ServiceException{}
	if err := p.Se.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Se, err)
	}
	return nil
}

func (p *ScanResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scan_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScanResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScanResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetSe() {
		if err := oprot.WriteFieldBegin("se", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:se: %s", p, err)
		}
		if err := p.Se.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Se, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:se: %s", p, err)
		}
	}
	return err
}

func (p *ScanResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScanResult(%+v)", *p)
}

type BatchArgs struct {
	Request *BatchRequest `thrift:"request,1" json:"request"`
}

func NewBatchArgs() *BatchArgs {
	return &BatchArgs{}
}

var BatchArgs_Request_DEFAULT *BatchRequest

func (p *BatchArgs) GetRequest() *BatchRequest {
	if !p.IsSetRequest() {
		return BatchArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *BatchArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *BatchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &BatchRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *BatchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *BatchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchArgs(%+v)", *p)
}

type BatchResult struct {
	Success *BatchResult_            `thrift:"success,0" json:"success"`
	Se      *errors.ServiceException `thrift:"se,1" json:"se"`
}

func NewBatchResult() *BatchResult {
	return &BatchResult{}
}

var BatchResult_Success_DEFAULT *BatchResult_

func (p *BatchResult) GetSuccess() *BatchResult_ {
	if !p.IsSetSuccess() {
		return BatchResult_Success_DEFAULT
	}
	return p.Success
}

var BatchResult_Se_DEFAULT *errors.ServiceException

func (p *BatchResult) GetSe() *errors.ServiceException {
	if !p.IsSetSe() {
		return BatchResult_Se_DEFAULT
	}
	return p.Se
}
func (p *BatchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BatchResult) IsSetSe() bool {
	return p.Se != nil
}

func (p *BatchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &BatchResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *BatchResult) ReadField1(iprot thrift.TProtocol) error {
	p.Se = &errors.ServiceException{}
	if err := p.Se.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Se, err)
	}
	return nil
}

func (p *BatchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *BatchResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetSe() {
		if err := oprot.WriteFieldBegin("se", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:se: %s", p, err)
		}
		if err := p.Se.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Se, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:se: %s", p, err)
		}
	}
	return err
}

func (p *BatchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchResult(%+v)", *p)
}
